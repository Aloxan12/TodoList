// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "data_types.proto" (package "auth", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { NullableBool } from "./struct";
import { NullableString } from "./struct";
import { NullableUInt64 } from "./struct";
/**
 * LoginUser (данные пользователя)
 *
 * @generated from protobuf message auth.LoginUser
 */
export interface LoginUser {
    /**
     * id пользователя
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id компании
     *
     * @generated from protobuf field: uint64 authorityId = 2;
     */
    authorityId: bigint;
    /**
     * email пользователя
     *
     * @generated from protobuf field: string email = 3;
     */
    email: string;
    /**
     * имя пользователя
     *
     * @generated from protobuf field: string name = 4;
     */
    name: string;
    /**
     * фамилия пользователя
     *
     * @generated from protobuf field: string surname = 5;
     */
    surname: string;
    /**
     * название компании
     *
     * @generated from protobuf field: string authorityName = 6;
     */
    authorityName: string;
    /**
     * роль пользователя, возможные значения OPERATOR, AGENT, ORGANIZER
     *
     * @generated from protobuf field: auth.UserType userType = 7;
     */
    userType: UserType;
}
/**
 * Kind
 *
 * @generated from protobuf message auth.KindList
 */
export interface KindList {
    /**
     * @generated from protobuf field: repeated auth.Kind kindList = 1;
     */
    kindList: Kind[];
}
/**
 * @generated from protobuf message auth.Kind
 */
export interface Kind {
    /**
     * id раздела
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название раздела
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * VenueType
 *
 * @generated from protobuf message auth.VenueTypeList
 */
export interface VenueTypeList {
    /**
     * @generated from protobuf field: repeated auth.VenueType venueType = 1;
     */
    venueType: VenueType[];
}
/**
 * @generated from protobuf message auth.VenueType
 */
export interface VenueType {
    /**
     * id типа
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название типа
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * Gateway (подключение к ВБС)
 *
 * @generated from protobuf message auth.GatewayList
 */
export interface GatewayList {
    /**
     * @generated from protobuf field: repeated auth.Gateway gatewayList = 1;
     */
    gatewayList: Gateway[];
}
/**
 * @generated from protobuf message auth.Gateway
 */
export interface Gateway {
    /**
     * id подключения
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id шлюза в ВБС
     *
     * @generated from protobuf field: uint32 systemId = 2;
     */
    systemId: number;
    /**
     * название подключения
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * название шлюза ВБС
     *
     * @generated from protobuf field: string systemName = 4;
     */
    systemName: string;
    /**
     * id компании-организатора, владельца подключения
     *
     * @generated from protobuf field: optional uint64 organizerId = 5;
     */
    organizerId?: bigint;
    /**
     * название компании-организатора, владельца подключения
     *
     * @generated from protobuf field: optional string organizerName = 6;
     */
    organizerName?: string;
}
/**
 * BarcodeFormat
 *
 * @generated from protobuf message auth.BarcodeFormatList
 */
export interface BarcodeFormatList {
    /**
     * @generated from protobuf field: repeated auth.BarcodeFormat barcodeFormat = 1;
     */
    barcodeFormat: BarcodeFormat[];
}
/**
 * @generated from protobuf message auth.BarcodeFormat
 */
export interface BarcodeFormat {
    /**
     * id формата штрихкода
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название формата штрихкода
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * QuotaFormat
 *
 * @generated from protobuf message auth.QuotaFormatList
 */
export interface QuotaFormatList {
    /**
     * @generated from protobuf field: repeated auth.QuotaFormat quotaFormat = 1;
     */
    quotaFormat: QuotaFormat[];
}
/**
 * @generated from protobuf message auth.QuotaFormat
 */
export interface QuotaFormat {
    /**
     * id формата файла квоты
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название формата файла квоты
     *
     * @generated from protobuf field: string desc = 2;
     */
    desc: string;
    /**
     * описание фильтра выбора файлов
     *
     * @generated from protobuf field: string fileFilterDesc = 3;
     */
    fileFilterDesc: string;
    /**
     * расширения файлов фильтра выбора файлов
     *
     * @generated from protobuf field: repeated string fileFilterExtensions = 4;
     */
    fileFilterExtensions: string[];
}
/**
 * BookletType
 *
 * @generated from protobuf message auth.BookletTypeList
 */
export interface BookletTypeList {
    /**
     * @generated from protobuf field: repeated auth.BookletType bookletTypeList = 1;
     */
    bookletTypeList: BookletType[];
}
/**
 * @generated from protobuf message auth.BookletType
 */
export interface BookletType {
    /**
     * id формата файла буклета
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название формата файла буклета
     *
     * @generated from protobuf field: string desc = 2;
     */
    desc: string;
    /**
     * описание фильтра выбора файлов
     *
     * @generated from protobuf field: string fileFilterDesc = 3;
     */
    fileFilterDesc: string;
    /**
     * расширение файла фильтра выбора файлов
     *
     * @generated from protobuf field: string extension = 4;
     */
    extension: string;
}
/**
 * Genre
 *
 * @generated from protobuf message auth.GenreList
 */
export interface GenreList {
    /**
     * @generated from protobuf field: repeated auth.Genre genre = 1;
     */
    genre: Genre[];
}
/**
 * @generated from protobuf message auth.Genre
 */
export interface Genre {
    /**
     * id жанра
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название жанра
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * ZoneId
 *
 * @generated from protobuf message auth.ZoneIdList
 */
export interface ZoneIdList {
    /**
     * @generated from protobuf field: repeated auth.ZoneId zoneId = 1;
     */
    zoneId: ZoneId[];
}
/**
 * @generated from protobuf message auth.ZoneId
 */
export interface ZoneId {
    /**
     * идентификатор часового пояса
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * строковое представление смещения относительно UTC
     *
     * @generated from protobuf field: string standardOffsetString = 2;
     */
    standardOffsetString: string;
    /**
     * смещение относительно UTC в секундах
     *
     * @generated from protobuf field: uint64 standardOffsetSeconds = 3;
     */
    standardOffsetSeconds: bigint;
}
/**
 * Currency
 *
 * @generated from protobuf message auth.CurrencyList
 */
export interface CurrencyList {
    /**
     * @generated from protobuf field: repeated auth.Currency currency = 1;
     */
    currency: Currency[];
}
/**
 * @generated from protobuf message auth.Currency
 */
export interface Currency {
    /**
     * трехбуквенный код валюты
     *
     * @generated from protobuf field: string currencyCode = 1;
     */
    currencyCode: string;
    /**
     * числовой код валюты
     *
     * @generated from protobuf field: uint32 numericCode = 2;
     */
    numericCode: number;
    /**
     * название валюты
     *
     * @generated from protobuf field: string displayName = 3;
     */
    displayName: string;
}
/**
 * EOrganizer
 *
 * @generated from protobuf message auth.EOrganizerList
 */
export interface EOrganizerList {
    /**
     * @generated from protobuf field: repeated auth.EOrganizer organizer = 1;
     */
    organizer: EOrganizer[];
}
/**
 * @generated from protobuf message auth.EOrganizer
 */
export interface EOrganizer {
    /**
     * id компании-организатора
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название компании-организатора
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * Country
 *
 * @generated from protobuf message auth.CountryList
 */
export interface CountryList {
    /**
     * @generated from protobuf field: repeated auth.Country country = 1;
     */
    country: Country[];
}
/**
 * @generated from protobuf message auth.Country
 */
export interface Country {
    /**
     * id страны
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название страны
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * City
 *
 * @generated from protobuf message auth.CityList
 */
export interface CityList {
    /**
     * @generated from protobuf field: repeated auth.City city = 1;
     */
    city: City[];
}
/**
 * @generated from protobuf message auth.City
 */
export interface City {
    /**
     * id города
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id страны
     *
     * @generated from protobuf field: uint64 countryId = 2;
     */
    countryId: bigint;
    /**
     * название города
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * идентификатор часового пояса
     *
     * @generated from protobuf field: string zoneId = 4;
     */
    zoneId: string;
}
/**
 * Venue
 *
 * @generated from protobuf message auth.SimpleVenueList
 */
export interface SimpleVenueList {
    /**
     * @generated from protobuf field: repeated auth.SimpleVenue simpleVenueList = 1;
     */
    simpleVenueList: SimpleVenue[];
}
/**
 * @generated from protobuf message auth.VenueList
 */
export interface VenueList {
    /**
     * @generated from protobuf field: repeated auth.VenueList venueList = 1;
     */
    venueList: VenueList[];
}
/**
 * @generated from protobuf message auth.SimpleVenue
 */
export interface SimpleVenue {
    /**
     * id места проведения
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id города
     *
     * @generated from protobuf field: uint64 cityId = 2;
     */
    cityId: bigint;
    /**
     * название города
     *
     * @generated from protobuf field: string cityName = 3;
     */
    cityName: string;
    /**
     * трехбуквенный код валюты по умолчанию для данного места проведения
     *
     * @generated from protobuf field: string currency = 4;
     */
    currency: string;
    /**
     * название места проведения
     *
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * тип места проведения
     *
     * @generated from protobuf field: auth.VenueType venueType = 6;
     */
    venueType?: VenueType;
    /**
     * адрес места проведения
     *
     * @generated from protobuf field: string address = 7;
     */
    address: string;
    /**
     * широта координат места проведения
     *
     * @generated from protobuf field: string geoLat = 8;
     */
    geoLat: string;
    /**
     * долгота координат места проведения
     *
     * @generated from protobuf field: string geoLon = 9;
     */
    geoLon: string;
    /**
     * описание места проведения
     *
     * @generated from protobuf field: string description = 10;
     */
    description: string;
    /**
     * @generated from protobuf field: string nameHex = 11;
     */
    nameHex: string;
}
/**
 * Venue
 *
 * @generated from protobuf message auth.Venue
 */
export interface Venue {
    /**
     * базовые значения места проведения
     *
     * @generated from protobuf field: auth.SimpleVenue simpleVenue = 1;
     */
    simpleVenue?: SimpleVenue;
    /**
     * изображение места проведения
     *
     * @generated from protobuf field: optional auth.Image bigImage = 11;
     */
    bigImage?: Image;
}
/**
 * Image
 *
 * @generated from protobuf message auth.Image
 */
export interface Image {
    /**
     * содержимое файла, кодированное в Base64, может быть пустым,
     * если содержимое надо запрашивать отдельно
     *
     * @generated from protobuf field: string img = 1;
     */
    img: string;
    /**
     * тип, расширение файла изображения
     *
     * @generated from protobuf field: string type = 2;
     */
    type: string;
    /**
     * контрольная сумма содержимого файла, используется
     * для контроля изменения изображения при кэшировании на стороне клиента
     *
     * @generated from protobuf field: string hash = 3;
     */
    hash: string;
}
/**
 * SeatingPlan
 *
 * @generated from protobuf message auth.SimpleSeatingPlanList
 */
export interface SimpleSeatingPlanList {
    /**
     * @generated from protobuf field: repeated auth.SimpleSeatingPlan seatingPlanList = 1;
     */
    seatingPlanList: SimpleSeatingPlan[];
}
/**
 * @generated from protobuf message auth.SeatingPlanList
 */
export interface SeatingPlanList {
    /**
     * @generated from protobuf field: repeated auth.SeatingPlan seatingPlanList = 1;
     */
    seatingPlanList: SeatingPlan[];
}
/**
 * @generated from protobuf message auth.SimpleSeatingPlan
 */
export interface SimpleSeatingPlan {
    /**
     * id схемы зала
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id места проведения
     *
     * @generated from protobuf field: uint64 venueId = 2;
     */
    venueId: bigint;
    /**
     * название места проведения
     *
     * @generated from protobuf field: string venueName = 3;
     */
    venueName: string;
    /**
     * трехбуквенный код валюты по умолчанию для данной схемы зала
     *
     * @generated from protobuf field: string currency = 4;
     */
    currency: string;
    /**
     * true – схема содержит места с размещением
     *
     * @generated from protobuf field: bool placement = 5;
     */
    placement: boolean;
    /**
     * название схемы зала
     *
     * @generated from protobuf field: string name = 6;
     */
    name: string;
    /**
     * список категорий схемы зала
     *
     * @generated from protobuf field: repeated auth.Category categoryList = 7;
     */
    categoryList: Category[];
    /**
     * список ограничений категорий
     *
     * @generated from protobuf field: repeated auth.CategoryLimit categoryLimitList = 8;
     */
    categoryLimitList: CategoryLimit[];
    /**
     * true – схема содержит spl файл
     *
     * @generated from protobuf field: bool splExists = 10;
     */
    splExists: boolean;
    /**
     * true – у пользователя есть права на удаление этой схемы
     *
     * @generated from protobuf field: bool owner = 11;
     */
    owner: boolean;
}
/**
 * @generated from protobuf message auth.SeatingPlan
 */
export interface SeatingPlan {
    /**
     * базовые значения схемы зала
     *
     * @generated from protobuf field: auth.SimpleSeatingPlan simpleSeatingPlan = 1;
     */
    simpleSeatingPlan?: SimpleSeatingPlan;
    /**
     * содержимое svg файла, сжатое gzip кодированное в Base64,
     * может отсутствовать, если содержимое надо запрашивать отдельно
     *
     * @generated from protobuf field: string svgZip = 2;
     */
    svgZip: string;
    /**
     * содержит PNG файл кодированный в Base64
     *
     * @generated from protobuf field: string png = 3;
     */
    png: string;
}
/**
 * Точка координат
 *
 * @generated from protobuf message auth.Point
 */
export interface Point {
    /**
     * @generated from protobuf field: double x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2;
     */
    y: number;
}
/**
 * Данные места
 *
 * @generated from protobuf message auth.SeatData
 */
export interface SeatData {
    /**
     * Координаты места на схеме
     *
     * @generated from protobuf field: auth.Point coodrinates = 1;
     */
    coodrinates?: Point;
    /**
     * id места
     *
     * @generated from protobuf field: uint64 seatId = 2;
     */
    seatId: bigint;
    /**
     * название места
     *
     * @generated from protobuf field: string sector = 3;
     */
    sector: string;
    /**
     * название ряда
     *
     * @generated from protobuf field: string row = 4;
     */
    row: string;
    /**
     * название места
     *
     * @generated from protobuf field: string number = 5;
     */
    number: string;
    /**
     * id категории
     *
     * @generated from protobuf field: uint64 categoryId = 6;
     */
    categoryId: bigint;
}
/**
 * Данные о местах схемы
 *
 * @generated from protobuf message auth.GetSeatingPlanFullData
 */
export interface GetSeatingPlanFullData {
    /**
     * базовые значения схемы зала
     *
     * @generated from protobuf field: auth.SeatingPlan seatingPlan = 1;
     */
    seatingPlan?: SeatingPlan;
    /**
     * данные мест
     *
     * @generated from protobuf field: repeated auth.SeatData seatDataList = 2;
     */
    seatDataList: SeatData[];
}
/**
 * Category
 *
 * @generated from protobuf message auth.Category
 */
export interface Category {
    /**
     * id категории
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * true – места в категории с размещением
     *
     * @generated from protobuf field: bool placement = 2;
     */
    placement: boolean;
    /**
     * название категории
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * количество мест в категории
     *
     * @generated from protobuf field: uint64 seatsNumber = 4;
     */
    seatsNumber: bigint;
    /**
     * начальная цена мест в категории
     *
     * @generated from protobuf field: optional double initPrice = 5;
     */
    initPrice?: number;
}
/**
 * @generated from protobuf message auth.CategoryLimit
 */
export interface CategoryLimit {
    /**
     * id ограничения категорий
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * список категорий, входящих в ограничение
     *
     * @generated from protobuf field: repeated auth.Category categoryList = 2;
     */
    categoryList: Category[];
    /**
     * общее максимальное количество мест,
     * которое можно продать в категориях, входящих в ограничение
     *
     * @generated from protobuf field: uint64 limit = 3;
     */
    limit: bigint;
}
/**
 * Action
 *
 * @generated from protobuf message auth.SimpleActionList
 */
export interface SimpleActionList {
    /**
     * @generated from protobuf field: repeated auth.SimpleAction simpleActionList = 1;
     */
    simpleActionList: SimpleAction[];
}
/**
 * @generated from protobuf message auth.ActionList
 */
export interface ActionList {
    /**
     * @generated from protobuf field: repeated auth.Action actionList = 1;
     */
    actionList: Action[];
}
/**
 * @generated from protobuf message auth.SimpleAction
 */
export interface SimpleAction {
    /**
     * TODO check description
     * id страны ???
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id компании-организатора, создателя представления
     *
     * @generated from protobuf field: uint64 organizerId = 2;
     */
    organizerId: bigint;
    /**
     * название компании-организатора, создателя представления
     *
     * @generated from protobuf field: string organizerName = 3;
     */
    organizerName: string;
    /**
     * раздел для представления
     *
     * @generated from protobuf field: auth.Kind kind = 4;
     */
    kind?: Kind;
    /**
     * краткое название представления
     *
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * полное название представления
     *
     * @generated from protobuf field: string fullName = 6;
     */
    fullName: string;
    /**
     * продолжительность представления в миллисекундах
     *
     * @generated from protobuf field: uint64 duration = 7;
     */
    duration: bigint;
    /**
     * заголовок описания представления
     *
     * @generated from protobuf field: string posterName = 8;
     */
    posterName: string;
    /**
     * описание представления
     *
     * @generated from protobuf field: string posterDesc = 9;
     */
    posterDesc: string;
    /**
     * формат постера, если есть
     *
     * @generated from protobuf field: optional auth.BookletType bookletType = 12;
     */
    bookletType?: BookletType;
    /**
     * рейтинг представления, число от 0 до 10 включительно
     *
     * @generated from protobuf field: uint64 rating = 13;
     */
    rating: bigint;
    /**
     * возрастное ограничение, может принимать значения:
     * UNKNOWN – не задано
     * C_0 – 0+
     * C_6 – 6+
     * C_12 – 12+
     * C_16 – 16+
     * C_18 – 18+
     *
     * @generated from protobuf field: auth.Age age = 14;
     */
    age: Age;
    /**
     * список всех жанров представления
     *
     * @generated from protobuf field: repeated auth.Genre genreSet = 15;
     */
    genreSet: Genre[];
    /**
     * название устроителя
     *
     * @generated from protobuf field: string legalOwner = 16;
     */
    legalOwner: string;
    /**
     * ИНН устроителя
     *
     * @generated from protobuf field: string legalOwnerInn = 17;
     */
    legalOwnerInn: string;
    /**
     * телефон устроителя
     *
     * @generated from protobuf field: string legalOwnerPhone = 18;
     */
    legalOwnerPhone: string;
    /**
     * минимальный сервисный сбор для представления
     *
     * @generated from protobuf field: double minChargePercent = 19;
     */
    minChargePercent: number;
    /**
     * КДП - код доступа к представлению
     *
     * @generated from protobuf field: optional uint64 kdp = 20;
     */
    kdp?: bigint;
    /**
     * список id городов, в которых идет представление
     *
     * @generated from protobuf field: repeated uint64 cityIdSet = 21;
     */
    cityIdSet: bigint[];
    /**
     * список id мест проведения, в которых идет представление
     *
     * @generated from protobuf field: repeated uint64 venueIdSet = 22;
     */
    venueIdSet: bigint[];
    /**
     * true – представление актуальное
     *
     * @generated from protobuf field: bool actual = 23;
     */
    actual: boolean;
}
/**
 * @generated from protobuf message auth.Action
 */
export interface Action {
    /**
     * Базовые значения представления
     *
     * @generated from protobuf field: auth.SimpleAction simpleAction = 1;
     */
    simpleAction?: SimpleAction;
    /**
     * изображение малого постера, если есть
     *
     * @generated from protobuf field: optional auth.Image smallImage = 10;
     */
    smallImage?: Image;
    /**
     * изображение большого постера, если есть
     *
     * @generated from protobuf field: optional auth.Image bigImage = 11;
     */
    bigImage?: Image;
}
/**
 * ActionEvent
 *
 * @generated from protobuf message auth.ActionEventList
 */
export interface ActionEventList {
    /**
     * @generated from protobuf field: repeated auth.ActionEvent actionEventList = 1;
     */
    actionEventList: ActionEvent[];
}
/**
 * @generated from protobuf message auth.ActionEvent
 */
export interface ActionEvent {
    /**
     * id сеанса
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * id схемы зала
     *
     * @generated from protobuf field: uint64 planId = 2;
     */
    planId: bigint;
    /**
     * название схемы зала
     *
     * @generated from protobuf field: string planName = 3;
     */
    planName: string;
    /**
     * id представления
     *
     * @generated from protobuf field: uint64 actionId = 4;
     */
    actionId: bigint;
    /**
     * название представления
     *
     * @generated from protobuf field: string actionName = 5;
     */
    actionName: string;
    /**
     * трехбуквенный код валюты сеанса
     *
     * @generated from protobuf field: string currency = 6;
     */
    currency: string;
    /**
     * true – сеанс использует квоту
     *
     * @generated from protobuf field: bool quota = 7;
     */
    quota: boolean;
    /**
     * список всех ценовых категорий сеанса
     *
     * @generated from protobuf field: repeated auth.CategoryPrice categoryPriceList = 8;
     */
    categoryPriceList: CategoryPrice[];
    /**
     * список всех тарифных планов сеанса
     *
     * @generated from protobuf field: repeated auth.TariffPlan tariffPlanList = 9;
     */
    tariffPlanList: TariffPlan[];
    /**
     * местное время начала сеанса в формате ISO-8601
     *
     * @generated from protobuf field: string showTime = 10;
     */
    showTime: string;
    /**
     * местное время начала продаж сеанса в формате ISO-8601
     *
     * @generated from protobuf field: string sellStartTime = 11;
     */
    sellStartTime: string;
    /**
     * местное время конца продаж сеанса в формате ISO-8601
     *
     * @generated from protobuf field: string sellEndTime = 12;
     */
    sellEndTime: string;
    /**
     * true – билеты на сеанс являются электронными
     *
     * @generated from protobuf field: bool eTickets = 13;
     */
    eTickets: boolean;
    /**
     * true – фамилия и имя покупателя на билете должны быть обязательно
     *
     * @generated from protobuf field: bool fullNameRequired = 14;
     */
    fullNameRequired: boolean;
    /**
     * true – номер телефона должен быть обязательно
     *
     * @generated from protobuf field: bool phoneRequired = 15;
     */
    phoneRequired: boolean;
    /**
     * true – на сеанс требуется fanId
     *
     * @generated from protobuf field: bool fanIdRequired = 16;
     */
    fanIdRequired: boolean;
    /**
     * true – возврат билетов разрешен
     *
     * @generated from protobuf field: bool ticketRefundAllowed = 17;
     */
    ticketRefundAllowed: boolean;
    /**
     * true – перепечать билетов разрешена
     *
     * @generated from protobuf field: bool ticketReissueAllowed = 18;
     */
    ticketReissueAllowed: boolean;
    /**
     * долговременное бронирование в миллисекундах, должно быть больше 0
     *
     * @generated from protobuf field: auth.NullableUInt64 maxReserveTime = 19;
     */
    maxReserveTime?: NullableUInt64;
    /**
     * максимальное кол-во билетов в одном заказе, должно быть больше 0
     *
     * @generated from protobuf field: auth.NullableUInt64 maxTickets = 20;
     */
    maxTickets?: NullableUInt64;
    /**
     * НДС
     *
     * @generated from protobuf field: double vat = 21;
     */
    vat: number;
    /**
     * true – продажа разрешена
     *
     * @generated from protobuf field: bool sellEnabled = 22;
     */
    sellEnabled: boolean;
    /**
     * true – сеанс содержит места с размещением
     *
     * @generated from protobuf field: bool placementPlan = 23;
     */
    placementPlan: boolean;
    /**
     * информация о связанном сеансе из ВБС
     *
     * @generated from protobuf field: auth.GatewayEvent gatewayEvent = 24;
     */
    gatewayEvent?: GatewayEvent;
    /**
     * true – сеанс в архиве, изменение невозможно
     *
     * @generated from protobuf field: bool archival = 25;
     */
    archival: boolean;
}
/**
 * @generated from protobuf message auth.EventSeatState
 */
export interface EventSeatState {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message auth.SeatLocation
 */
export interface SeatLocation {
    /**
     * @generated from protobuf field: string sector = 1;
     */
    sector: string;
    /**
     * @generated from protobuf field: string row = 2;
     */
    row: string;
    /**
     * @generated from protobuf field: string number = 3;
     */
    number: string;
}
/**
 * @generated from protobuf message auth.EventSeat
 */
export interface EventSeat {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: auth.CategoryPrice categoryPrice = 2;
     */
    categoryPrice?: CategoryPrice;
    /**
     * @generated from protobuf field: auth.EventSeatState state = 3;
     */
    state?: EventSeatState;
    /**
     * @generated from protobuf field: optional auth.SeatLocation seatLocation = 4;
     */
    seatLocation?: SeatLocation;
    /**
     * @generated from protobuf field: optional string barcode = 5;
     */
    barcode?: string;
}
/**
 * @generated from protobuf message auth.ActionEventData
 */
export interface ActionEventData {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: optional string svgData = 2;
     */
    svgData?: string;
    /**
     * @generated from protobuf field: int32 mismatchedPrice = 3;
     */
    mismatchedPrice: number;
    /**
     * @generated from protobuf field: int32 mismatchedName = 4;
     */
    mismatchedName: number;
    /**
     * @generated from protobuf field: int32 mismatchedSeat = 5;
     */
    mismatchedSeat: number;
    /**
     * @generated from protobuf field: bool splExists = 6;
     */
    splExists: boolean;
    /**
     * @generated from protobuf field: repeated uint64 etsNotAvailIdSet = 7;
     */
    etsNotAvailIdSet: bigint[];
    /**
     * @generated from protobuf field: repeated auth.TariffPlan tariffPlanList = 8;
     */
    tariffPlanList: TariffPlan[];
    /**
     * @generated from protobuf field: repeated auth.CategoryPrice categoryPriceList = 9;
     */
    categoryPriceList: CategoryPrice[];
    /**
     * @generated from protobuf field: repeated auth.EventSeat eventSeatList = 10;
     */
    eventSeatList: EventSeat[];
}
/**
 * CategoryPrice
 *
 * @generated from protobuf message auth.CategoryPrice
 */
export interface CategoryPrice {
    /**
     * id ценовой категории
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * true – места в категории с размещением
     *
     * @generated from protobuf field: bool placement = 2;
     */
    placement: boolean;
    /**
     * название ценовой категории
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * цена мест в категории
     *
     * @generated from protobuf field: double price = 4;
     */
    price: number;
    /**
     * количество свободных мест в категории
     *
     * @generated from protobuf field: uint64 availability = 5;
     */
    availability: bigint;
}
/**
 * TariffPlan
 *
 * @generated from protobuf message auth.TariffPlan
 */
export interface TariffPlan {
    /**
     * id тарифного плана
     *
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * название тарифного плана
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * ассоциативный массив, key – id ценовой категории (число Ulong),
     * value – цена по тарифу (число cur)
     *
     * @generated from protobuf field: map<uint64, double> tariffMap = 3;
     */
    tariffMap: {
        [key: string]: number;
    };
}
/**
 * GatewayEvent (сеанс в ВБС)
 *
 * @generated from protobuf message auth.GatewayEventList
 */
export interface GatewayEventList {
    /**
     * @generated from protobuf field: repeated auth.GatewayEvent gatewayEventList = 1;
     */
    gatewayEventList: GatewayEvent[];
}
/**
 * @generated from protobuf message auth.GatewayEvent
 */
export interface GatewayEvent {
    /**
     * подключение к ВБС
     *
     * @generated from protobuf field: auth.Gateway gateway = 1;
     */
    gateway?: Gateway;
    /**
     * id сеанса в ВБС
     *
     * @generated from protobuf field: string eventId = 2;
     */
    eventId: string;
    /**
     * uid сеанса в ВБС
     *
     * @generated from protobuf field: string eventUid = 3;
     */
    eventUid: string;
    /**
     * местное время начала сеанса в формате ISO-8601
     *
     * @generated from protobuf field: string showTime = 4;
     */
    showTime: string;
    /**
     * местное время конца продаж сеанса в формате ISO-8601 если есть
     *
     * @generated from protobuf field: auth.NullableString sellEndTime = 5;
     */
    sellEndTime?: NullableString;
    /**
     * трехбуквенный код валюты сеанса
     *
     * @generated from protobuf field: string currency = 6;
     */
    currency: string;
    /**
     * id представления в ВБС
     *
     * @generated from protobuf field: auth.NullableString actionId = 7;
     */
    actionId?: NullableString;
    /**
     * название представления в ВБС
     *
     * @generated from protobuf field: string actionName = 8;
     */
    actionName: string;
    /**
     * id места проведения в ВБС
     *
     * @generated from protobuf field: auth.NullableString venueId = 9;
     */
    venueId?: NullableString;
    /**
     * название места проведения в ВБС
     *
     * @generated from protobuf field: string venueName = 10;
     */
    venueName: string;
    /**
     * id зала (схемы зала) в ВБС
     *
     * @generated from protobuf field: auth.NullableString planId = 11;
     */
    planId?: NullableString;
    /**
     * название зала (схемы зала) в ВБС
     *
     * @generated from protobuf field: auth.NullableString planName = 12;
     */
    planName?: NullableString;
    /**
     * дополнительные данные о сеансе, зависят от шлюза в ВБС
     *
     * @generated from protobuf field: repeated string data = 13;
     */
    data: string[];
    /**
     * причина несовместимости, невозможности продажи данного сеанса
     *
     * @generated from protobuf field: auth.NullableString incompatibilityReason = 14;
     */
    incompatibilityReason?: NullableString;
    /**
     * true – фамилия и имя покупателя на билете должны быть обязательно
     *
     * @generated from protobuf field: auth.NullableBool fullNameRequired = 15;
     */
    fullNameRequired?: NullableBool;
    /**
     * true – номер телефона должен быть обязательно
     *
     * @generated from protobuf field: auth.NullableBool phoneRequired = 16;
     */
    phoneRequired?: NullableBool;
    /**
     * true – на сеанс требуется fanId
     *
     * @generated from protobuf field: auth.NullableBool fanIdRequired = 17;
     */
    fanIdRequired?: NullableBool;
    /**
     * true – возврат билетов разрешен
     *
     * @generated from protobuf field: auth.NullableBool ticketRefundAllowed = 18;
     */
    ticketRefundAllowed?: NullableBool;
    /**
     * true – перепечать билетов разрешена
     *
     * @generated from protobuf field: auth.NullableBool ticketReissueAllowed = 19;
     */
    ticketReissueAllowed?: NullableBool;
    /**
     * максимальное кол-во билетов в одном заказе, должно быть больше 0
     *
     * @generated from protobuf field: auth.NullableUInt64 maxTickets = 20;
     */
    maxTickets?: NullableUInt64;
}
/**
 * @generated from protobuf enum auth.UserType
 */
export enum UserType {
    /**
     * @generated from protobuf enum value: operator = 0;
     */
    operator = 0,
    /**
     * @generated from protobuf enum value: agent = 1;
     */
    agent = 1,
    /**
     * @generated from protobuf enum value: organizer = 2;
     */
    organizer = 2
}
/**
 * @generated from protobuf enum auth.Age
 */
export enum Age {
    /**
     * C_0 – 0+
     *
     * @generated from protobuf enum value: C_0 = 0;
     */
    C_0 = 0,
    /**
     * C_6 – 6+
     *
     * @generated from protobuf enum value: C_6 = 1;
     */
    C_6 = 1,
    /**
     * C_12 – 12+
     *
     * @generated from protobuf enum value: C_12 = 2;
     */
    C_12 = 2,
    /**
     * C_16 – 16+
     *
     * @generated from protobuf enum value: C_16 = 3;
     */
    C_16 = 3,
    /**
     * C_18 – 18+
     *
     * @generated from protobuf enum value: C_18 = 4;
     */
    C_18 = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class LoginUser$Type extends MessageType<LoginUser> {
    constructor() {
        super("auth.LoginUser", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "authorityId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "surname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "authorityName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "userType", kind: "enum", T: () => ["auth.UserType", UserType] }
        ]);
    }
    create(value?: PartialMessage<LoginUser>): LoginUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.authorityId = 0n;
        message.email = "";
        message.name = "";
        message.surname = "";
        message.authorityName = "";
        message.userType = 0;
        if (value !== undefined)
            reflectionMergePartial<LoginUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginUser): LoginUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 authorityId */ 2:
                    message.authorityId = reader.uint64().toBigInt();
                    break;
                case /* string email */ 3:
                    message.email = reader.string();
                    break;
                case /* string name */ 4:
                    message.name = reader.string();
                    break;
                case /* string surname */ 5:
                    message.surname = reader.string();
                    break;
                case /* string authorityName */ 6:
                    message.authorityName = reader.string();
                    break;
                case /* auth.UserType userType */ 7:
                    message.userType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 authorityId = 2; */
        if (message.authorityId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.authorityId);
        /* string email = 3; */
        if (message.email !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.email);
        /* string name = 4; */
        if (message.name !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.name);
        /* string surname = 5; */
        if (message.surname !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.surname);
        /* string authorityName = 6; */
        if (message.authorityName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.authorityName);
        /* auth.UserType userType = 7; */
        if (message.userType !== 0)
            writer.tag(7, WireType.Varint).int32(message.userType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.LoginUser
 */
export const LoginUser = new LoginUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KindList$Type extends MessageType<KindList> {
    constructor() {
        super("auth.KindList", [
            { no: 1, name: "kindList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Kind }
        ]);
    }
    create(value?: PartialMessage<KindList>): KindList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kindList = [];
        if (value !== undefined)
            reflectionMergePartial<KindList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KindList): KindList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.Kind kindList */ 1:
                    message.kindList.push(Kind.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KindList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.Kind kindList = 1; */
        for (let i = 0; i < message.kindList.length; i++)
            Kind.internalBinaryWrite(message.kindList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.KindList
 */
export const KindList = new KindList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Kind$Type extends MessageType<Kind> {
    constructor() {
        super("auth.Kind", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Kind>): Kind {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Kind>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Kind): Kind {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Kind, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Kind
 */
export const Kind = new Kind$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VenueTypeList$Type extends MessageType<VenueTypeList> {
    constructor() {
        super("auth.VenueTypeList", [
            { no: 1, name: "venueType", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VenueType }
        ]);
    }
    create(value?: PartialMessage<VenueTypeList>): VenueTypeList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.venueType = [];
        if (value !== undefined)
            reflectionMergePartial<VenueTypeList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VenueTypeList): VenueTypeList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.VenueType venueType */ 1:
                    message.venueType.push(VenueType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VenueTypeList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.VenueType venueType = 1; */
        for (let i = 0; i < message.venueType.length; i++)
            VenueType.internalBinaryWrite(message.venueType[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.VenueTypeList
 */
export const VenueTypeList = new VenueTypeList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VenueType$Type extends MessageType<VenueType> {
    constructor() {
        super("auth.VenueType", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<VenueType>): VenueType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<VenueType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VenueType): VenueType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VenueType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.VenueType
 */
export const VenueType = new VenueType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayList$Type extends MessageType<GatewayList> {
    constructor() {
        super("auth.GatewayList", [
            { no: 1, name: "gatewayList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Gateway }
        ]);
    }
    create(value?: PartialMessage<GatewayList>): GatewayList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayList = [];
        if (value !== undefined)
            reflectionMergePartial<GatewayList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GatewayList): GatewayList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.Gateway gatewayList */ 1:
                    message.gatewayList.push(Gateway.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatewayList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.Gateway gatewayList = 1; */
        for (let i = 0; i < message.gatewayList.length; i++)
            Gateway.internalBinaryWrite(message.gatewayList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.GatewayList
 */
export const GatewayList = new GatewayList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gateway$Type extends MessageType<Gateway> {
    constructor() {
        super("auth.Gateway", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "systemId", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "systemName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "organizerId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "organizerName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Gateway>): Gateway {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.systemId = 0;
        message.name = "";
        message.systemName = "";
        if (value !== undefined)
            reflectionMergePartial<Gateway>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gateway): Gateway {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint32 systemId */ 2:
                    message.systemId = reader.uint32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string systemName */ 4:
                    message.systemName = reader.string();
                    break;
                case /* optional uint64 organizerId */ 5:
                    message.organizerId = reader.uint64().toBigInt();
                    break;
                case /* optional string organizerName */ 6:
                    message.organizerName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gateway, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint32 systemId = 2; */
        if (message.systemId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.systemId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string systemName = 4; */
        if (message.systemName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.systemName);
        /* optional uint64 organizerId = 5; */
        if (message.organizerId !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.organizerId);
        /* optional string organizerName = 6; */
        if (message.organizerName !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.organizerName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Gateway
 */
export const Gateway = new Gateway$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BarcodeFormatList$Type extends MessageType<BarcodeFormatList> {
    constructor() {
        super("auth.BarcodeFormatList", [
            { no: 1, name: "barcodeFormat", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BarcodeFormat }
        ]);
    }
    create(value?: PartialMessage<BarcodeFormatList>): BarcodeFormatList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.barcodeFormat = [];
        if (value !== undefined)
            reflectionMergePartial<BarcodeFormatList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BarcodeFormatList): BarcodeFormatList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.BarcodeFormat barcodeFormat */ 1:
                    message.barcodeFormat.push(BarcodeFormat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BarcodeFormatList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.BarcodeFormat barcodeFormat = 1; */
        for (let i = 0; i < message.barcodeFormat.length; i++)
            BarcodeFormat.internalBinaryWrite(message.barcodeFormat[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.BarcodeFormatList
 */
export const BarcodeFormatList = new BarcodeFormatList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BarcodeFormat$Type extends MessageType<BarcodeFormat> {
    constructor() {
        super("auth.BarcodeFormat", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BarcodeFormat>): BarcodeFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<BarcodeFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BarcodeFormat): BarcodeFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BarcodeFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.BarcodeFormat
 */
export const BarcodeFormat = new BarcodeFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaFormatList$Type extends MessageType<QuotaFormatList> {
    constructor() {
        super("auth.QuotaFormatList", [
            { no: 1, name: "quotaFormat", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QuotaFormat }
        ]);
    }
    create(value?: PartialMessage<QuotaFormatList>): QuotaFormatList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quotaFormat = [];
        if (value !== undefined)
            reflectionMergePartial<QuotaFormatList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaFormatList): QuotaFormatList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.QuotaFormat quotaFormat */ 1:
                    message.quotaFormat.push(QuotaFormat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuotaFormatList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.QuotaFormat quotaFormat = 1; */
        for (let i = 0; i < message.quotaFormat.length; i++)
            QuotaFormat.internalBinaryWrite(message.quotaFormat[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.QuotaFormatList
 */
export const QuotaFormatList = new QuotaFormatList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuotaFormat$Type extends MessageType<QuotaFormat> {
    constructor() {
        super("auth.QuotaFormat", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fileFilterDesc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "fileFilterExtensions", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuotaFormat>): QuotaFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.desc = "";
        message.fileFilterDesc = "";
        message.fileFilterExtensions = [];
        if (value !== undefined)
            reflectionMergePartial<QuotaFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaFormat): QuotaFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string desc */ 2:
                    message.desc = reader.string();
                    break;
                case /* string fileFilterDesc */ 3:
                    message.fileFilterDesc = reader.string();
                    break;
                case /* repeated string fileFilterExtensions */ 4:
                    message.fileFilterExtensions.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuotaFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string desc = 2; */
        if (message.desc !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.desc);
        /* string fileFilterDesc = 3; */
        if (message.fileFilterDesc !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileFilterDesc);
        /* repeated string fileFilterExtensions = 4; */
        for (let i = 0; i < message.fileFilterExtensions.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.fileFilterExtensions[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.QuotaFormat
 */
export const QuotaFormat = new QuotaFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BookletTypeList$Type extends MessageType<BookletTypeList> {
    constructor() {
        super("auth.BookletTypeList", [
            { no: 1, name: "bookletTypeList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => BookletType }
        ]);
    }
    create(value?: PartialMessage<BookletTypeList>): BookletTypeList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.bookletTypeList = [];
        if (value !== undefined)
            reflectionMergePartial<BookletTypeList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BookletTypeList): BookletTypeList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.BookletType bookletTypeList */ 1:
                    message.bookletTypeList.push(BookletType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BookletTypeList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.BookletType bookletTypeList = 1; */
        for (let i = 0; i < message.bookletTypeList.length; i++)
            BookletType.internalBinaryWrite(message.bookletTypeList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.BookletTypeList
 */
export const BookletTypeList = new BookletTypeList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BookletType$Type extends MessageType<BookletType> {
    constructor() {
        super("auth.BookletType", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fileFilterDesc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "extension", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BookletType>): BookletType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.desc = "";
        message.fileFilterDesc = "";
        message.extension = "";
        if (value !== undefined)
            reflectionMergePartial<BookletType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BookletType): BookletType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string desc */ 2:
                    message.desc = reader.string();
                    break;
                case /* string fileFilterDesc */ 3:
                    message.fileFilterDesc = reader.string();
                    break;
                case /* string extension */ 4:
                    message.extension = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BookletType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string desc = 2; */
        if (message.desc !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.desc);
        /* string fileFilterDesc = 3; */
        if (message.fileFilterDesc !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.fileFilterDesc);
        /* string extension = 4; */
        if (message.extension !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.extension);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.BookletType
 */
export const BookletType = new BookletType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenreList$Type extends MessageType<GenreList> {
    constructor() {
        super("auth.GenreList", [
            { no: 1, name: "genre", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Genre }
        ]);
    }
    create(value?: PartialMessage<GenreList>): GenreList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.genre = [];
        if (value !== undefined)
            reflectionMergePartial<GenreList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenreList): GenreList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.Genre genre */ 1:
                    message.genre.push(Genre.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenreList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.Genre genre = 1; */
        for (let i = 0; i < message.genre.length; i++)
            Genre.internalBinaryWrite(message.genre[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.GenreList
 */
export const GenreList = new GenreList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Genre$Type extends MessageType<Genre> {
    constructor() {
        super("auth.Genre", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Genre>): Genre {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Genre>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Genre): Genre {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Genre, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Genre
 */
export const Genre = new Genre$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneIdList$Type extends MessageType<ZoneIdList> {
    constructor() {
        super("auth.ZoneIdList", [
            { no: 1, name: "zoneId", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ZoneId }
        ]);
    }
    create(value?: PartialMessage<ZoneIdList>): ZoneIdList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.zoneId = [];
        if (value !== undefined)
            reflectionMergePartial<ZoneIdList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneIdList): ZoneIdList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.ZoneId zoneId */ 1:
                    message.zoneId.push(ZoneId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneIdList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.ZoneId zoneId = 1; */
        for (let i = 0; i < message.zoneId.length; i++)
            ZoneId.internalBinaryWrite(message.zoneId[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.ZoneIdList
 */
export const ZoneIdList = new ZoneIdList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ZoneId$Type extends MessageType<ZoneId> {
    constructor() {
        super("auth.ZoneId", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "standardOffsetString", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "standardOffsetSeconds", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ZoneId>): ZoneId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.standardOffsetString = "";
        message.standardOffsetSeconds = 0n;
        if (value !== undefined)
            reflectionMergePartial<ZoneId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ZoneId): ZoneId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string standardOffsetString */ 2:
                    message.standardOffsetString = reader.string();
                    break;
                case /* uint64 standardOffsetSeconds */ 3:
                    message.standardOffsetSeconds = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ZoneId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string standardOffsetString = 2; */
        if (message.standardOffsetString !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.standardOffsetString);
        /* uint64 standardOffsetSeconds = 3; */
        if (message.standardOffsetSeconds !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.standardOffsetSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.ZoneId
 */
export const ZoneId = new ZoneId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrencyList$Type extends MessageType<CurrencyList> {
    constructor() {
        super("auth.CurrencyList", [
            { no: 1, name: "currency", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Currency }
        ]);
    }
    create(value?: PartialMessage<CurrencyList>): CurrencyList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currency = [];
        if (value !== undefined)
            reflectionMergePartial<CurrencyList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrencyList): CurrencyList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.Currency currency */ 1:
                    message.currency.push(Currency.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrencyList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.Currency currency = 1; */
        for (let i = 0; i < message.currency.length; i++)
            Currency.internalBinaryWrite(message.currency[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.CurrencyList
 */
export const CurrencyList = new CurrencyList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Currency$Type extends MessageType<Currency> {
    constructor() {
        super("auth.Currency", [
            { no: 1, name: "currencyCode", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "numericCode", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "displayName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Currency>): Currency {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currencyCode = "";
        message.numericCode = 0;
        message.displayName = "";
        if (value !== undefined)
            reflectionMergePartial<Currency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Currency): Currency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string currencyCode */ 1:
                    message.currencyCode = reader.string();
                    break;
                case /* uint32 numericCode */ 2:
                    message.numericCode = reader.uint32();
                    break;
                case /* string displayName */ 3:
                    message.displayName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Currency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string currencyCode = 1; */
        if (message.currencyCode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.currencyCode);
        /* uint32 numericCode = 2; */
        if (message.numericCode !== 0)
            writer.tag(2, WireType.Varint).uint32(message.numericCode);
        /* string displayName = 3; */
        if (message.displayName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.displayName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Currency
 */
export const Currency = new Currency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOrganizerList$Type extends MessageType<EOrganizerList> {
    constructor() {
        super("auth.EOrganizerList", [
            { no: 1, name: "organizer", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EOrganizer }
        ]);
    }
    create(value?: PartialMessage<EOrganizerList>): EOrganizerList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.organizer = [];
        if (value !== undefined)
            reflectionMergePartial<EOrganizerList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOrganizerList): EOrganizerList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.EOrganizer organizer */ 1:
                    message.organizer.push(EOrganizer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOrganizerList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.EOrganizer organizer = 1; */
        for (let i = 0; i < message.organizer.length; i++)
            EOrganizer.internalBinaryWrite(message.organizer[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.EOrganizerList
 */
export const EOrganizerList = new EOrganizerList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOrganizer$Type extends MessageType<EOrganizer> {
    constructor() {
        super("auth.EOrganizer", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EOrganizer>): EOrganizer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<EOrganizer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOrganizer): EOrganizer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOrganizer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.EOrganizer
 */
export const EOrganizer = new EOrganizer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CountryList$Type extends MessageType<CountryList> {
    constructor() {
        super("auth.CountryList", [
            { no: 1, name: "country", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Country }
        ]);
    }
    create(value?: PartialMessage<CountryList>): CountryList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.country = [];
        if (value !== undefined)
            reflectionMergePartial<CountryList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CountryList): CountryList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.Country country */ 1:
                    message.country.push(Country.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CountryList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.Country country = 1; */
        for (let i = 0; i < message.country.length; i++)
            Country.internalBinaryWrite(message.country[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.CountryList
 */
export const CountryList = new CountryList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Country$Type extends MessageType<Country> {
    constructor() {
        super("auth.Country", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Country>): Country {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Country>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Country): Country {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Country, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Country
 */
export const Country = new Country$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CityList$Type extends MessageType<CityList> {
    constructor() {
        super("auth.CityList", [
            { no: 1, name: "city", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => City }
        ]);
    }
    create(value?: PartialMessage<CityList>): CityList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.city = [];
        if (value !== undefined)
            reflectionMergePartial<CityList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CityList): CityList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.City city */ 1:
                    message.city.push(City.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CityList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.City city = 1; */
        for (let i = 0; i < message.city.length; i++)
            City.internalBinaryWrite(message.city[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.CityList
 */
export const CityList = new CityList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class City$Type extends MessageType<City> {
    constructor() {
        super("auth.City", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "countryId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "zoneId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<City>): City {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.countryId = 0n;
        message.name = "";
        message.zoneId = "";
        if (value !== undefined)
            reflectionMergePartial<City>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: City): City {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 countryId */ 2:
                    message.countryId = reader.uint64().toBigInt();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string zoneId */ 4:
                    message.zoneId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: City, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 countryId = 2; */
        if (message.countryId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.countryId);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string zoneId = 4; */
        if (message.zoneId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.zoneId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.City
 */
export const City = new City$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleVenueList$Type extends MessageType<SimpleVenueList> {
    constructor() {
        super("auth.SimpleVenueList", [
            { no: 1, name: "simpleVenueList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SimpleVenue }
        ]);
    }
    create(value?: PartialMessage<SimpleVenueList>): SimpleVenueList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.simpleVenueList = [];
        if (value !== undefined)
            reflectionMergePartial<SimpleVenueList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleVenueList): SimpleVenueList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.SimpleVenue simpleVenueList */ 1:
                    message.simpleVenueList.push(SimpleVenue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleVenueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.SimpleVenue simpleVenueList = 1; */
        for (let i = 0; i < message.simpleVenueList.length; i++)
            SimpleVenue.internalBinaryWrite(message.simpleVenueList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SimpleVenueList
 */
export const SimpleVenueList = new SimpleVenueList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VenueList$Type extends MessageType<VenueList> {
    constructor() {
        super("auth.VenueList", [
            { no: 1, name: "venueList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => VenueList }
        ]);
    }
    create(value?: PartialMessage<VenueList>): VenueList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.venueList = [];
        if (value !== undefined)
            reflectionMergePartial<VenueList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VenueList): VenueList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.VenueList venueList */ 1:
                    message.venueList.push(VenueList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VenueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.VenueList venueList = 1; */
        for (let i = 0; i < message.venueList.length; i++)
            VenueList.internalBinaryWrite(message.venueList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.VenueList
 */
export const VenueList = new VenueList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleVenue$Type extends MessageType<SimpleVenue> {
    constructor() {
        super("auth.SimpleVenue", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "cityId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "cityName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "venueType", kind: "message", T: () => VenueType },
            { no: 7, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "geoLat", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "geoLon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "nameHex", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleVenue>): SimpleVenue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.cityId = 0n;
        message.cityName = "";
        message.currency = "";
        message.name = "";
        message.address = "";
        message.geoLat = "";
        message.geoLon = "";
        message.description = "";
        message.nameHex = "";
        if (value !== undefined)
            reflectionMergePartial<SimpleVenue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleVenue): SimpleVenue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 cityId */ 2:
                    message.cityId = reader.uint64().toBigInt();
                    break;
                case /* string cityName */ 3:
                    message.cityName = reader.string();
                    break;
                case /* string currency */ 4:
                    message.currency = reader.string();
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* auth.VenueType venueType */ 6:
                    message.venueType = VenueType.internalBinaryRead(reader, reader.uint32(), options, message.venueType);
                    break;
                case /* string address */ 7:
                    message.address = reader.string();
                    break;
                case /* string geoLat */ 8:
                    message.geoLat = reader.string();
                    break;
                case /* string geoLon */ 9:
                    message.geoLon = reader.string();
                    break;
                case /* string description */ 10:
                    message.description = reader.string();
                    break;
                case /* string nameHex */ 11:
                    message.nameHex = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleVenue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 cityId = 2; */
        if (message.cityId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.cityId);
        /* string cityName = 3; */
        if (message.cityName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.cityName);
        /* string currency = 4; */
        if (message.currency !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currency);
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* auth.VenueType venueType = 6; */
        if (message.venueType)
            VenueType.internalBinaryWrite(message.venueType, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string address = 7; */
        if (message.address !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.address);
        /* string geoLat = 8; */
        if (message.geoLat !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.geoLat);
        /* string geoLon = 9; */
        if (message.geoLon !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.geoLon);
        /* string description = 10; */
        if (message.description !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.description);
        /* string nameHex = 11; */
        if (message.nameHex !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.nameHex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SimpleVenue
 */
export const SimpleVenue = new SimpleVenue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Venue$Type extends MessageType<Venue> {
    constructor() {
        super("auth.Venue", [
            { no: 1, name: "simpleVenue", kind: "message", T: () => SimpleVenue },
            { no: 11, name: "bigImage", kind: "message", T: () => Image }
        ]);
    }
    create(value?: PartialMessage<Venue>): Venue {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Venue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Venue): Venue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.SimpleVenue simpleVenue */ 1:
                    message.simpleVenue = SimpleVenue.internalBinaryRead(reader, reader.uint32(), options, message.simpleVenue);
                    break;
                case /* optional auth.Image bigImage */ 11:
                    message.bigImage = Image.internalBinaryRead(reader, reader.uint32(), options, message.bigImage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Venue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* auth.SimpleVenue simpleVenue = 1; */
        if (message.simpleVenue)
            SimpleVenue.internalBinaryWrite(message.simpleVenue, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional auth.Image bigImage = 11; */
        if (message.bigImage)
            Image.internalBinaryWrite(message.bigImage, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Venue
 */
export const Venue = new Venue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Image$Type extends MessageType<Image> {
    constructor() {
        super("auth.Image", [
            { no: 1, name: "img", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Image>): Image {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.img = "";
        message.type = "";
        message.hash = "";
        if (value !== undefined)
            reflectionMergePartial<Image>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Image): Image {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string img */ 1:
                    message.img = reader.string();
                    break;
                case /* string type */ 2:
                    message.type = reader.string();
                    break;
                case /* string hash */ 3:
                    message.hash = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Image, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string img = 1; */
        if (message.img !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.img);
        /* string type = 2; */
        if (message.type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type);
        /* string hash = 3; */
        if (message.hash !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Image
 */
export const Image = new Image$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleSeatingPlanList$Type extends MessageType<SimpleSeatingPlanList> {
    constructor() {
        super("auth.SimpleSeatingPlanList", [
            { no: 1, name: "seatingPlanList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SimpleSeatingPlan }
        ]);
    }
    create(value?: PartialMessage<SimpleSeatingPlanList>): SimpleSeatingPlanList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seatingPlanList = [];
        if (value !== undefined)
            reflectionMergePartial<SimpleSeatingPlanList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleSeatingPlanList): SimpleSeatingPlanList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.SimpleSeatingPlan seatingPlanList */ 1:
                    message.seatingPlanList.push(SimpleSeatingPlan.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleSeatingPlanList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.SimpleSeatingPlan seatingPlanList = 1; */
        for (let i = 0; i < message.seatingPlanList.length; i++)
            SimpleSeatingPlan.internalBinaryWrite(message.seatingPlanList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SimpleSeatingPlanList
 */
export const SimpleSeatingPlanList = new SimpleSeatingPlanList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SeatingPlanList$Type extends MessageType<SeatingPlanList> {
    constructor() {
        super("auth.SeatingPlanList", [
            { no: 1, name: "seatingPlanList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SeatingPlan }
        ]);
    }
    create(value?: PartialMessage<SeatingPlanList>): SeatingPlanList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seatingPlanList = [];
        if (value !== undefined)
            reflectionMergePartial<SeatingPlanList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SeatingPlanList): SeatingPlanList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.SeatingPlan seatingPlanList */ 1:
                    message.seatingPlanList.push(SeatingPlan.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SeatingPlanList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.SeatingPlan seatingPlanList = 1; */
        for (let i = 0; i < message.seatingPlanList.length; i++)
            SeatingPlan.internalBinaryWrite(message.seatingPlanList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SeatingPlanList
 */
export const SeatingPlanList = new SeatingPlanList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleSeatingPlan$Type extends MessageType<SimpleSeatingPlan> {
    constructor() {
        super("auth.SimpleSeatingPlan", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "venueId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "venueName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "placement", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "categoryList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Category },
            { no: 8, name: "categoryLimitList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CategoryLimit },
            { no: 10, name: "splExists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "owner", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleSeatingPlan>): SimpleSeatingPlan {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.venueId = 0n;
        message.venueName = "";
        message.currency = "";
        message.placement = false;
        message.name = "";
        message.categoryList = [];
        message.categoryLimitList = [];
        message.splExists = false;
        message.owner = false;
        if (value !== undefined)
            reflectionMergePartial<SimpleSeatingPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleSeatingPlan): SimpleSeatingPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 venueId */ 2:
                    message.venueId = reader.uint64().toBigInt();
                    break;
                case /* string venueName */ 3:
                    message.venueName = reader.string();
                    break;
                case /* string currency */ 4:
                    message.currency = reader.string();
                    break;
                case /* bool placement */ 5:
                    message.placement = reader.bool();
                    break;
                case /* string name */ 6:
                    message.name = reader.string();
                    break;
                case /* repeated auth.Category categoryList */ 7:
                    message.categoryList.push(Category.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated auth.CategoryLimit categoryLimitList */ 8:
                    message.categoryLimitList.push(CategoryLimit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool splExists */ 10:
                    message.splExists = reader.bool();
                    break;
                case /* bool owner */ 11:
                    message.owner = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleSeatingPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 venueId = 2; */
        if (message.venueId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.venueId);
        /* string venueName = 3; */
        if (message.venueName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.venueName);
        /* string currency = 4; */
        if (message.currency !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.currency);
        /* bool placement = 5; */
        if (message.placement !== false)
            writer.tag(5, WireType.Varint).bool(message.placement);
        /* string name = 6; */
        if (message.name !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.name);
        /* repeated auth.Category categoryList = 7; */
        for (let i = 0; i < message.categoryList.length; i++)
            Category.internalBinaryWrite(message.categoryList[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.CategoryLimit categoryLimitList = 8; */
        for (let i = 0; i < message.categoryLimitList.length; i++)
            CategoryLimit.internalBinaryWrite(message.categoryLimitList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool splExists = 10; */
        if (message.splExists !== false)
            writer.tag(10, WireType.Varint).bool(message.splExists);
        /* bool owner = 11; */
        if (message.owner !== false)
            writer.tag(11, WireType.Varint).bool(message.owner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SimpleSeatingPlan
 */
export const SimpleSeatingPlan = new SimpleSeatingPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SeatingPlan$Type extends MessageType<SeatingPlan> {
    constructor() {
        super("auth.SeatingPlan", [
            { no: 1, name: "simpleSeatingPlan", kind: "message", T: () => SimpleSeatingPlan },
            { no: 2, name: "svgZip", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "png", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SeatingPlan>): SeatingPlan {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.svgZip = "";
        message.png = "";
        if (value !== undefined)
            reflectionMergePartial<SeatingPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SeatingPlan): SeatingPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.SimpleSeatingPlan simpleSeatingPlan */ 1:
                    message.simpleSeatingPlan = SimpleSeatingPlan.internalBinaryRead(reader, reader.uint32(), options, message.simpleSeatingPlan);
                    break;
                case /* string svgZip */ 2:
                    message.svgZip = reader.string();
                    break;
                case /* string png */ 3:
                    message.png = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SeatingPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* auth.SimpleSeatingPlan simpleSeatingPlan = 1; */
        if (message.simpleSeatingPlan)
            SimpleSeatingPlan.internalBinaryWrite(message.simpleSeatingPlan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string svgZip = 2; */
        if (message.svgZip !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.svgZip);
        /* string png = 3; */
        if (message.png !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.png);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SeatingPlan
 */
export const SeatingPlan = new SeatingPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Point$Type extends MessageType<Point> {
    constructor() {
        super("auth.Point", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Point>): Point {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Point>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Point): Point {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Point, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Point
 */
export const Point = new Point$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SeatData$Type extends MessageType<SeatData> {
    constructor() {
        super("auth.SeatData", [
            { no: 1, name: "coodrinates", kind: "message", T: () => Point },
            { no: 2, name: "seatId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "row", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "categoryId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SeatData>): SeatData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seatId = 0n;
        message.sector = "";
        message.row = "";
        message.number = "";
        message.categoryId = 0n;
        if (value !== undefined)
            reflectionMergePartial<SeatData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SeatData): SeatData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.Point coodrinates */ 1:
                    message.coodrinates = Point.internalBinaryRead(reader, reader.uint32(), options, message.coodrinates);
                    break;
                case /* uint64 seatId */ 2:
                    message.seatId = reader.uint64().toBigInt();
                    break;
                case /* string sector */ 3:
                    message.sector = reader.string();
                    break;
                case /* string row */ 4:
                    message.row = reader.string();
                    break;
                case /* string number */ 5:
                    message.number = reader.string();
                    break;
                case /* uint64 categoryId */ 6:
                    message.categoryId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SeatData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* auth.Point coodrinates = 1; */
        if (message.coodrinates)
            Point.internalBinaryWrite(message.coodrinates, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 seatId = 2; */
        if (message.seatId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.seatId);
        /* string sector = 3; */
        if (message.sector !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sector);
        /* string row = 4; */
        if (message.row !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.row);
        /* string number = 5; */
        if (message.number !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.number);
        /* uint64 categoryId = 6; */
        if (message.categoryId !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.categoryId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SeatData
 */
export const SeatData = new SeatData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSeatingPlanFullData$Type extends MessageType<GetSeatingPlanFullData> {
    constructor() {
        super("auth.GetSeatingPlanFullData", [
            { no: 1, name: "seatingPlan", kind: "message", T: () => SeatingPlan },
            { no: 2, name: "seatDataList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SeatData }
        ]);
    }
    create(value?: PartialMessage<GetSeatingPlanFullData>): GetSeatingPlanFullData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.seatDataList = [];
        if (value !== undefined)
            reflectionMergePartial<GetSeatingPlanFullData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSeatingPlanFullData): GetSeatingPlanFullData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.SeatingPlan seatingPlan */ 1:
                    message.seatingPlan = SeatingPlan.internalBinaryRead(reader, reader.uint32(), options, message.seatingPlan);
                    break;
                case /* repeated auth.SeatData seatDataList */ 2:
                    message.seatDataList.push(SeatData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSeatingPlanFullData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* auth.SeatingPlan seatingPlan = 1; */
        if (message.seatingPlan)
            SeatingPlan.internalBinaryWrite(message.seatingPlan, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.SeatData seatDataList = 2; */
        for (let i = 0; i < message.seatDataList.length; i++)
            SeatData.internalBinaryWrite(message.seatDataList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.GetSeatingPlanFullData
 */
export const GetSeatingPlanFullData = new GetSeatingPlanFullData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Category$Type extends MessageType<Category> {
    constructor() {
        super("auth.Category", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "placement", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "seatsNumber", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "initPrice", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<Category>): Category {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.placement = false;
        message.name = "";
        message.seatsNumber = 0n;
        if (value !== undefined)
            reflectionMergePartial<Category>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Category): Category {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* bool placement */ 2:
                    message.placement = reader.bool();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* uint64 seatsNumber */ 4:
                    message.seatsNumber = reader.uint64().toBigInt();
                    break;
                case /* optional double initPrice */ 5:
                    message.initPrice = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Category, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* bool placement = 2; */
        if (message.placement !== false)
            writer.tag(2, WireType.Varint).bool(message.placement);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* uint64 seatsNumber = 4; */
        if (message.seatsNumber !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.seatsNumber);
        /* optional double initPrice = 5; */
        if (message.initPrice !== undefined)
            writer.tag(5, WireType.Bit64).double(message.initPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Category
 */
export const Category = new Category$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryLimit$Type extends MessageType<CategoryLimit> {
    constructor() {
        super("auth.CategoryLimit", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "categoryList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Category },
            { no: 3, name: "limit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CategoryLimit>): CategoryLimit {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.categoryList = [];
        message.limit = 0n;
        if (value !== undefined)
            reflectionMergePartial<CategoryLimit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CategoryLimit): CategoryLimit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* repeated auth.Category categoryList */ 2:
                    message.categoryList.push(Category.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 limit */ 3:
                    message.limit = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CategoryLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* repeated auth.Category categoryList = 2; */
        for (let i = 0; i < message.categoryList.length; i++)
            Category.internalBinaryWrite(message.categoryList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 limit = 3; */
        if (message.limit !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.CategoryLimit
 */
export const CategoryLimit = new CategoryLimit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleActionList$Type extends MessageType<SimpleActionList> {
    constructor() {
        super("auth.SimpleActionList", [
            { no: 1, name: "simpleActionList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SimpleAction }
        ]);
    }
    create(value?: PartialMessage<SimpleActionList>): SimpleActionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.simpleActionList = [];
        if (value !== undefined)
            reflectionMergePartial<SimpleActionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleActionList): SimpleActionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.SimpleAction simpleActionList */ 1:
                    message.simpleActionList.push(SimpleAction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleActionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.SimpleAction simpleActionList = 1; */
        for (let i = 0; i < message.simpleActionList.length; i++)
            SimpleAction.internalBinaryWrite(message.simpleActionList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SimpleActionList
 */
export const SimpleActionList = new SimpleActionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionList$Type extends MessageType<ActionList> {
    constructor() {
        super("auth.ActionList", [
            { no: 1, name: "actionList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Action }
        ]);
    }
    create(value?: PartialMessage<ActionList>): ActionList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionList = [];
        if (value !== undefined)
            reflectionMergePartial<ActionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionList): ActionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.Action actionList */ 1:
                    message.actionList.push(Action.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.Action actionList = 1; */
        for (let i = 0; i < message.actionList.length; i++)
            Action.internalBinaryWrite(message.actionList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.ActionList
 */
export const ActionList = new ActionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleAction$Type extends MessageType<SimpleAction> {
    constructor() {
        super("auth.SimpleAction", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "organizerId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "organizerName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "kind", kind: "message", T: () => Kind },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fullName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "duration", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "posterName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "posterDesc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "bookletType", kind: "message", T: () => BookletType },
            { no: 13, name: "rating", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "age", kind: "enum", T: () => ["auth.Age", Age] },
            { no: 15, name: "genreSet", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Genre },
            { no: 16, name: "legalOwner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "legalOwnerInn", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "legalOwnerPhone", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "minChargePercent", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 20, name: "kdp", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 21, name: "cityIdSet", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 22, name: "venueIdSet", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 23, name: "actual", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleAction>): SimpleAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.organizerId = 0n;
        message.organizerName = "";
        message.name = "";
        message.fullName = "";
        message.duration = 0n;
        message.posterName = "";
        message.posterDesc = "";
        message.rating = 0n;
        message.age = 0;
        message.genreSet = [];
        message.legalOwner = "";
        message.legalOwnerInn = "";
        message.legalOwnerPhone = "";
        message.minChargePercent = 0;
        message.cityIdSet = [];
        message.venueIdSet = [];
        message.actual = false;
        if (value !== undefined)
            reflectionMergePartial<SimpleAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleAction): SimpleAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 organizerId */ 2:
                    message.organizerId = reader.uint64().toBigInt();
                    break;
                case /* string organizerName */ 3:
                    message.organizerName = reader.string();
                    break;
                case /* auth.Kind kind */ 4:
                    message.kind = Kind.internalBinaryRead(reader, reader.uint32(), options, message.kind);
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string fullName */ 6:
                    message.fullName = reader.string();
                    break;
                case /* uint64 duration */ 7:
                    message.duration = reader.uint64().toBigInt();
                    break;
                case /* string posterName */ 8:
                    message.posterName = reader.string();
                    break;
                case /* string posterDesc */ 9:
                    message.posterDesc = reader.string();
                    break;
                case /* optional auth.BookletType bookletType */ 12:
                    message.bookletType = BookletType.internalBinaryRead(reader, reader.uint32(), options, message.bookletType);
                    break;
                case /* uint64 rating */ 13:
                    message.rating = reader.uint64().toBigInt();
                    break;
                case /* auth.Age age */ 14:
                    message.age = reader.int32();
                    break;
                case /* repeated auth.Genre genreSet */ 15:
                    message.genreSet.push(Genre.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string legalOwner */ 16:
                    message.legalOwner = reader.string();
                    break;
                case /* string legalOwnerInn */ 17:
                    message.legalOwnerInn = reader.string();
                    break;
                case /* string legalOwnerPhone */ 18:
                    message.legalOwnerPhone = reader.string();
                    break;
                case /* double minChargePercent */ 19:
                    message.minChargePercent = reader.double();
                    break;
                case /* optional uint64 kdp */ 20:
                    message.kdp = reader.uint64().toBigInt();
                    break;
                case /* repeated uint64 cityIdSet */ 21:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.cityIdSet.push(reader.uint64().toBigInt());
                    else
                        message.cityIdSet.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 venueIdSet */ 22:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.venueIdSet.push(reader.uint64().toBigInt());
                    else
                        message.venueIdSet.push(reader.uint64().toBigInt());
                    break;
                case /* bool actual */ 23:
                    message.actual = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 organizerId = 2; */
        if (message.organizerId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.organizerId);
        /* string organizerName = 3; */
        if (message.organizerName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.organizerName);
        /* auth.Kind kind = 4; */
        if (message.kind)
            Kind.internalBinaryWrite(message.kind, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string fullName = 6; */
        if (message.fullName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fullName);
        /* uint64 duration = 7; */
        if (message.duration !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.duration);
        /* string posterName = 8; */
        if (message.posterName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.posterName);
        /* string posterDesc = 9; */
        if (message.posterDesc !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.posterDesc);
        /* optional auth.BookletType bookletType = 12; */
        if (message.bookletType)
            BookletType.internalBinaryWrite(message.bookletType, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* uint64 rating = 13; */
        if (message.rating !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.rating);
        /* auth.Age age = 14; */
        if (message.age !== 0)
            writer.tag(14, WireType.Varint).int32(message.age);
        /* repeated auth.Genre genreSet = 15; */
        for (let i = 0; i < message.genreSet.length; i++)
            Genre.internalBinaryWrite(message.genreSet[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* string legalOwner = 16; */
        if (message.legalOwner !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.legalOwner);
        /* string legalOwnerInn = 17; */
        if (message.legalOwnerInn !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.legalOwnerInn);
        /* string legalOwnerPhone = 18; */
        if (message.legalOwnerPhone !== "")
            writer.tag(18, WireType.LengthDelimited).string(message.legalOwnerPhone);
        /* double minChargePercent = 19; */
        if (message.minChargePercent !== 0)
            writer.tag(19, WireType.Bit64).double(message.minChargePercent);
        /* optional uint64 kdp = 20; */
        if (message.kdp !== undefined)
            writer.tag(20, WireType.Varint).uint64(message.kdp);
        /* repeated uint64 cityIdSet = 21; */
        if (message.cityIdSet.length) {
            writer.tag(21, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.cityIdSet.length; i++)
                writer.uint64(message.cityIdSet[i]);
            writer.join();
        }
        /* repeated uint64 venueIdSet = 22; */
        if (message.venueIdSet.length) {
            writer.tag(22, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.venueIdSet.length; i++)
                writer.uint64(message.venueIdSet[i]);
            writer.join();
        }
        /* bool actual = 23; */
        if (message.actual !== false)
            writer.tag(23, WireType.Varint).bool(message.actual);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SimpleAction
 */
export const SimpleAction = new SimpleAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Action$Type extends MessageType<Action> {
    constructor() {
        super("auth.Action", [
            { no: 1, name: "simpleAction", kind: "message", T: () => SimpleAction },
            { no: 10, name: "smallImage", kind: "message", T: () => Image },
            { no: 11, name: "bigImage", kind: "message", T: () => Image }
        ]);
    }
    create(value?: PartialMessage<Action>): Action {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Action>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Action): Action {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.SimpleAction simpleAction */ 1:
                    message.simpleAction = SimpleAction.internalBinaryRead(reader, reader.uint32(), options, message.simpleAction);
                    break;
                case /* optional auth.Image smallImage */ 10:
                    message.smallImage = Image.internalBinaryRead(reader, reader.uint32(), options, message.smallImage);
                    break;
                case /* optional auth.Image bigImage */ 11:
                    message.bigImage = Image.internalBinaryRead(reader, reader.uint32(), options, message.bigImage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Action, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* auth.SimpleAction simpleAction = 1; */
        if (message.simpleAction)
            SimpleAction.internalBinaryWrite(message.simpleAction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional auth.Image smallImage = 10; */
        if (message.smallImage)
            Image.internalBinaryWrite(message.smallImage, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* optional auth.Image bigImage = 11; */
        if (message.bigImage)
            Image.internalBinaryWrite(message.bigImage, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.Action
 */
export const Action = new Action$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionEventList$Type extends MessageType<ActionEventList> {
    constructor() {
        super("auth.ActionEventList", [
            { no: 1, name: "actionEventList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ActionEvent }
        ]);
    }
    create(value?: PartialMessage<ActionEventList>): ActionEventList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionEventList = [];
        if (value !== undefined)
            reflectionMergePartial<ActionEventList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionEventList): ActionEventList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.ActionEvent actionEventList */ 1:
                    message.actionEventList.push(ActionEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionEventList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.ActionEvent actionEventList = 1; */
        for (let i = 0; i < message.actionEventList.length; i++)
            ActionEvent.internalBinaryWrite(message.actionEventList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.ActionEventList
 */
export const ActionEventList = new ActionEventList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionEvent$Type extends MessageType<ActionEvent> {
    constructor() {
        super("auth.ActionEvent", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "planId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "planName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "actionId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "actionName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quota", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "categoryPriceList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CategoryPrice },
            { no: 9, name: "tariffPlanList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TariffPlan },
            { no: 10, name: "showTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "sellStartTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "sellEndTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "eTickets", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "fullNameRequired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "phoneRequired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "fanIdRequired", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "ticketRefundAllowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "ticketReissueAllowed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 19, name: "maxReserveTime", kind: "message", T: () => NullableUInt64 },
            { no: 20, name: "maxTickets", kind: "message", T: () => NullableUInt64 },
            { no: 21, name: "vat", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 22, name: "sellEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 23, name: "placementPlan", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 24, name: "gatewayEvent", kind: "message", T: () => GatewayEvent },
            { no: 25, name: "archival", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ActionEvent>): ActionEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.planId = 0n;
        message.planName = "";
        message.actionId = 0n;
        message.actionName = "";
        message.currency = "";
        message.quota = false;
        message.categoryPriceList = [];
        message.tariffPlanList = [];
        message.showTime = "";
        message.sellStartTime = "";
        message.sellEndTime = "";
        message.eTickets = false;
        message.fullNameRequired = false;
        message.phoneRequired = false;
        message.fanIdRequired = false;
        message.ticketRefundAllowed = false;
        message.ticketReissueAllowed = false;
        message.vat = 0;
        message.sellEnabled = false;
        message.placementPlan = false;
        message.archival = false;
        if (value !== undefined)
            reflectionMergePartial<ActionEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionEvent): ActionEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 planId */ 2:
                    message.planId = reader.uint64().toBigInt();
                    break;
                case /* string planName */ 3:
                    message.planName = reader.string();
                    break;
                case /* uint64 actionId */ 4:
                    message.actionId = reader.uint64().toBigInt();
                    break;
                case /* string actionName */ 5:
                    message.actionName = reader.string();
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* bool quota */ 7:
                    message.quota = reader.bool();
                    break;
                case /* repeated auth.CategoryPrice categoryPriceList */ 8:
                    message.categoryPriceList.push(CategoryPrice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated auth.TariffPlan tariffPlanList */ 9:
                    message.tariffPlanList.push(TariffPlan.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string showTime */ 10:
                    message.showTime = reader.string();
                    break;
                case /* string sellStartTime */ 11:
                    message.sellStartTime = reader.string();
                    break;
                case /* string sellEndTime */ 12:
                    message.sellEndTime = reader.string();
                    break;
                case /* bool eTickets */ 13:
                    message.eTickets = reader.bool();
                    break;
                case /* bool fullNameRequired */ 14:
                    message.fullNameRequired = reader.bool();
                    break;
                case /* bool phoneRequired */ 15:
                    message.phoneRequired = reader.bool();
                    break;
                case /* bool fanIdRequired */ 16:
                    message.fanIdRequired = reader.bool();
                    break;
                case /* bool ticketRefundAllowed */ 17:
                    message.ticketRefundAllowed = reader.bool();
                    break;
                case /* bool ticketReissueAllowed */ 18:
                    message.ticketReissueAllowed = reader.bool();
                    break;
                case /* auth.NullableUInt64 maxReserveTime */ 19:
                    message.maxReserveTime = NullableUInt64.internalBinaryRead(reader, reader.uint32(), options, message.maxReserveTime);
                    break;
                case /* auth.NullableUInt64 maxTickets */ 20:
                    message.maxTickets = NullableUInt64.internalBinaryRead(reader, reader.uint32(), options, message.maxTickets);
                    break;
                case /* double vat */ 21:
                    message.vat = reader.double();
                    break;
                case /* bool sellEnabled */ 22:
                    message.sellEnabled = reader.bool();
                    break;
                case /* bool placementPlan */ 23:
                    message.placementPlan = reader.bool();
                    break;
                case /* auth.GatewayEvent gatewayEvent */ 24:
                    message.gatewayEvent = GatewayEvent.internalBinaryRead(reader, reader.uint32(), options, message.gatewayEvent);
                    break;
                case /* bool archival */ 25:
                    message.archival = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 planId = 2; */
        if (message.planId !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.planId);
        /* string planName = 3; */
        if (message.planName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.planName);
        /* uint64 actionId = 4; */
        if (message.actionId !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.actionId);
        /* string actionName = 5; */
        if (message.actionName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.actionName);
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* bool quota = 7; */
        if (message.quota !== false)
            writer.tag(7, WireType.Varint).bool(message.quota);
        /* repeated auth.CategoryPrice categoryPriceList = 8; */
        for (let i = 0; i < message.categoryPriceList.length; i++)
            CategoryPrice.internalBinaryWrite(message.categoryPriceList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.TariffPlan tariffPlanList = 9; */
        for (let i = 0; i < message.tariffPlanList.length; i++)
            TariffPlan.internalBinaryWrite(message.tariffPlanList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string showTime = 10; */
        if (message.showTime !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.showTime);
        /* string sellStartTime = 11; */
        if (message.sellStartTime !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.sellStartTime);
        /* string sellEndTime = 12; */
        if (message.sellEndTime !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.sellEndTime);
        /* bool eTickets = 13; */
        if (message.eTickets !== false)
            writer.tag(13, WireType.Varint).bool(message.eTickets);
        /* bool fullNameRequired = 14; */
        if (message.fullNameRequired !== false)
            writer.tag(14, WireType.Varint).bool(message.fullNameRequired);
        /* bool phoneRequired = 15; */
        if (message.phoneRequired !== false)
            writer.tag(15, WireType.Varint).bool(message.phoneRequired);
        /* bool fanIdRequired = 16; */
        if (message.fanIdRequired !== false)
            writer.tag(16, WireType.Varint).bool(message.fanIdRequired);
        /* bool ticketRefundAllowed = 17; */
        if (message.ticketRefundAllowed !== false)
            writer.tag(17, WireType.Varint).bool(message.ticketRefundAllowed);
        /* bool ticketReissueAllowed = 18; */
        if (message.ticketReissueAllowed !== false)
            writer.tag(18, WireType.Varint).bool(message.ticketReissueAllowed);
        /* auth.NullableUInt64 maxReserveTime = 19; */
        if (message.maxReserveTime)
            NullableUInt64.internalBinaryWrite(message.maxReserveTime, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableUInt64 maxTickets = 20; */
        if (message.maxTickets)
            NullableUInt64.internalBinaryWrite(message.maxTickets, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* double vat = 21; */
        if (message.vat !== 0)
            writer.tag(21, WireType.Bit64).double(message.vat);
        /* bool sellEnabled = 22; */
        if (message.sellEnabled !== false)
            writer.tag(22, WireType.Varint).bool(message.sellEnabled);
        /* bool placementPlan = 23; */
        if (message.placementPlan !== false)
            writer.tag(23, WireType.Varint).bool(message.placementPlan);
        /* auth.GatewayEvent gatewayEvent = 24; */
        if (message.gatewayEvent)
            GatewayEvent.internalBinaryWrite(message.gatewayEvent, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* bool archival = 25; */
        if (message.archival !== false)
            writer.tag(25, WireType.Varint).bool(message.archival);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.ActionEvent
 */
export const ActionEvent = new ActionEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSeatState$Type extends MessageType<EventSeatState> {
    constructor() {
        super("auth.EventSeatState", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventSeatState>): EventSeatState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.description = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<EventSeatState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSeatState): EventSeatState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSeatState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.EventSeatState
 */
export const EventSeatState = new EventSeatState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SeatLocation$Type extends MessageType<SeatLocation> {
    constructor() {
        super("auth.SeatLocation", [
            { no: 1, name: "sector", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "row", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "number", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SeatLocation>): SeatLocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sector = "";
        message.row = "";
        message.number = "";
        if (value !== undefined)
            reflectionMergePartial<SeatLocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SeatLocation): SeatLocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sector */ 1:
                    message.sector = reader.string();
                    break;
                case /* string row */ 2:
                    message.row = reader.string();
                    break;
                case /* string number */ 3:
                    message.number = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SeatLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sector = 1; */
        if (message.sector !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sector);
        /* string row = 2; */
        if (message.row !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.row);
        /* string number = 3; */
        if (message.number !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.SeatLocation
 */
export const SeatLocation = new SeatLocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventSeat$Type extends MessageType<EventSeat> {
    constructor() {
        super("auth.EventSeat", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "categoryPrice", kind: "message", T: () => CategoryPrice },
            { no: 3, name: "state", kind: "message", T: () => EventSeatState },
            { no: 4, name: "seatLocation", kind: "message", T: () => SeatLocation },
            { no: 5, name: "barcode", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EventSeat>): EventSeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<EventSeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventSeat): EventSeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* auth.CategoryPrice categoryPrice */ 2:
                    message.categoryPrice = CategoryPrice.internalBinaryRead(reader, reader.uint32(), options, message.categoryPrice);
                    break;
                case /* auth.EventSeatState state */ 3:
                    message.state = EventSeatState.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                case /* optional auth.SeatLocation seatLocation */ 4:
                    message.seatLocation = SeatLocation.internalBinaryRead(reader, reader.uint32(), options, message.seatLocation);
                    break;
                case /* optional string barcode */ 5:
                    message.barcode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventSeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* auth.CategoryPrice categoryPrice = 2; */
        if (message.categoryPrice)
            CategoryPrice.internalBinaryWrite(message.categoryPrice, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* auth.EventSeatState state = 3; */
        if (message.state)
            EventSeatState.internalBinaryWrite(message.state, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional auth.SeatLocation seatLocation = 4; */
        if (message.seatLocation)
            SeatLocation.internalBinaryWrite(message.seatLocation, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string barcode = 5; */
        if (message.barcode !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.barcode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.EventSeat
 */
export const EventSeat = new EventSeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionEventData$Type extends MessageType<ActionEventData> {
    constructor() {
        super("auth.ActionEventData", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "svgData", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mismatchedPrice", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "mismatchedName", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "mismatchedSeat", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "splExists", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "etsNotAvailIdSet", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "tariffPlanList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TariffPlan },
            { no: 9, name: "categoryPriceList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CategoryPrice },
            { no: 10, name: "eventSeatList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EventSeat }
        ]);
    }
    create(value?: PartialMessage<ActionEventData>): ActionEventData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.mismatchedPrice = 0;
        message.mismatchedName = 0;
        message.mismatchedSeat = 0;
        message.splExists = false;
        message.etsNotAvailIdSet = [];
        message.tariffPlanList = [];
        message.categoryPriceList = [];
        message.eventSeatList = [];
        if (value !== undefined)
            reflectionMergePartial<ActionEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionEventData): ActionEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* optional string svgData */ 2:
                    message.svgData = reader.string();
                    break;
                case /* int32 mismatchedPrice */ 3:
                    message.mismatchedPrice = reader.int32();
                    break;
                case /* int32 mismatchedName */ 4:
                    message.mismatchedName = reader.int32();
                    break;
                case /* int32 mismatchedSeat */ 5:
                    message.mismatchedSeat = reader.int32();
                    break;
                case /* bool splExists */ 6:
                    message.splExists = reader.bool();
                    break;
                case /* repeated uint64 etsNotAvailIdSet */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.etsNotAvailIdSet.push(reader.uint64().toBigInt());
                    else
                        message.etsNotAvailIdSet.push(reader.uint64().toBigInt());
                    break;
                case /* repeated auth.TariffPlan tariffPlanList */ 8:
                    message.tariffPlanList.push(TariffPlan.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated auth.CategoryPrice categoryPriceList */ 9:
                    message.categoryPriceList.push(CategoryPrice.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated auth.EventSeat eventSeatList */ 10:
                    message.eventSeatList.push(EventSeat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* optional string svgData = 2; */
        if (message.svgData !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.svgData);
        /* int32 mismatchedPrice = 3; */
        if (message.mismatchedPrice !== 0)
            writer.tag(3, WireType.Varint).int32(message.mismatchedPrice);
        /* int32 mismatchedName = 4; */
        if (message.mismatchedName !== 0)
            writer.tag(4, WireType.Varint).int32(message.mismatchedName);
        /* int32 mismatchedSeat = 5; */
        if (message.mismatchedSeat !== 0)
            writer.tag(5, WireType.Varint).int32(message.mismatchedSeat);
        /* bool splExists = 6; */
        if (message.splExists !== false)
            writer.tag(6, WireType.Varint).bool(message.splExists);
        /* repeated uint64 etsNotAvailIdSet = 7; */
        if (message.etsNotAvailIdSet.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.etsNotAvailIdSet.length; i++)
                writer.uint64(message.etsNotAvailIdSet[i]);
            writer.join();
        }
        /* repeated auth.TariffPlan tariffPlanList = 8; */
        for (let i = 0; i < message.tariffPlanList.length; i++)
            TariffPlan.internalBinaryWrite(message.tariffPlanList[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.CategoryPrice categoryPriceList = 9; */
        for (let i = 0; i < message.categoryPriceList.length; i++)
            CategoryPrice.internalBinaryWrite(message.categoryPriceList[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated auth.EventSeat eventSeatList = 10; */
        for (let i = 0; i < message.eventSeatList.length; i++)
            EventSeat.internalBinaryWrite(message.eventSeatList[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.ActionEventData
 */
export const ActionEventData = new ActionEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryPrice$Type extends MessageType<CategoryPrice> {
    constructor() {
        super("auth.CategoryPrice", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "placement", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "availability", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CategoryPrice>): CategoryPrice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.placement = false;
        message.name = "";
        message.price = 0;
        message.availability = 0n;
        if (value !== undefined)
            reflectionMergePartial<CategoryPrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CategoryPrice): CategoryPrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* bool placement */ 2:
                    message.placement = reader.bool();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* double price */ 4:
                    message.price = reader.double();
                    break;
                case /* uint64 availability */ 5:
                    message.availability = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CategoryPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* bool placement = 2; */
        if (message.placement !== false)
            writer.tag(2, WireType.Varint).bool(message.placement);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* double price = 4; */
        if (message.price !== 0)
            writer.tag(4, WireType.Bit64).double(message.price);
        /* uint64 availability = 5; */
        if (message.availability !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.availability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.CategoryPrice
 */
export const CategoryPrice = new CategoryPrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TariffPlan$Type extends MessageType<TariffPlan> {
    constructor() {
        super("auth.TariffPlan", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tariffMap", kind: "map", K: 4 /*ScalarType.UINT64*/, V: { kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ } }
        ]);
    }
    create(value?: PartialMessage<TariffPlan>): TariffPlan {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.name = "";
        message.tariffMap = {};
        if (value !== undefined)
            reflectionMergePartial<TariffPlan>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TariffPlan): TariffPlan {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* map<uint64, double> tariffMap */ 3:
                    this.binaryReadMap3(message.tariffMap, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: TariffPlan["tariffMap"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TariffPlan["tariffMap"] | undefined, val: TariffPlan["tariffMap"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.uint64().toString();
                    break;
                case 2:
                    val = reader.double();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field auth.TariffPlan.tariffMap");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    internalBinaryWrite(message: TariffPlan, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* map<uint64, double> tariffMap = 3; */
        for (let k of globalThis.Object.keys(message.tariffMap))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).uint64(k).tag(2, WireType.Bit64).double(message.tariffMap[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.TariffPlan
 */
export const TariffPlan = new TariffPlan$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayEventList$Type extends MessageType<GatewayEventList> {
    constructor() {
        super("auth.GatewayEventList", [
            { no: 1, name: "gatewayEventList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GatewayEvent }
        ]);
    }
    create(value?: PartialMessage<GatewayEventList>): GatewayEventList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.gatewayEventList = [];
        if (value !== undefined)
            reflectionMergePartial<GatewayEventList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GatewayEventList): GatewayEventList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated auth.GatewayEvent gatewayEventList */ 1:
                    message.gatewayEventList.push(GatewayEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatewayEventList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated auth.GatewayEvent gatewayEventList = 1; */
        for (let i = 0; i < message.gatewayEventList.length; i++)
            GatewayEvent.internalBinaryWrite(message.gatewayEventList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.GatewayEventList
 */
export const GatewayEventList = new GatewayEventList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GatewayEvent$Type extends MessageType<GatewayEvent> {
    constructor() {
        super("auth.GatewayEvent", [
            { no: 1, name: "gateway", kind: "message", T: () => Gateway },
            { no: 2, name: "eventId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "eventUid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "showTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "sellEndTime", kind: "message", T: () => NullableString },
            { no: 6, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "actionId", kind: "message", T: () => NullableString },
            { no: 8, name: "actionName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "venueId", kind: "message", T: () => NullableString },
            { no: 10, name: "venueName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "planId", kind: "message", T: () => NullableString },
            { no: 12, name: "planName", kind: "message", T: () => NullableString },
            { no: 13, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "incompatibilityReason", kind: "message", T: () => NullableString },
            { no: 15, name: "fullNameRequired", kind: "message", T: () => NullableBool },
            { no: 16, name: "phoneRequired", kind: "message", T: () => NullableBool },
            { no: 17, name: "fanIdRequired", kind: "message", T: () => NullableBool },
            { no: 18, name: "ticketRefundAllowed", kind: "message", T: () => NullableBool },
            { no: 19, name: "ticketReissueAllowed", kind: "message", T: () => NullableBool },
            { no: 20, name: "maxTickets", kind: "message", T: () => NullableUInt64 }
        ]);
    }
    create(value?: PartialMessage<GatewayEvent>): GatewayEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.eventId = "";
        message.eventUid = "";
        message.showTime = "";
        message.currency = "";
        message.actionName = "";
        message.venueName = "";
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<GatewayEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GatewayEvent): GatewayEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* auth.Gateway gateway */ 1:
                    message.gateway = Gateway.internalBinaryRead(reader, reader.uint32(), options, message.gateway);
                    break;
                case /* string eventId */ 2:
                    message.eventId = reader.string();
                    break;
                case /* string eventUid */ 3:
                    message.eventUid = reader.string();
                    break;
                case /* string showTime */ 4:
                    message.showTime = reader.string();
                    break;
                case /* auth.NullableString sellEndTime */ 5:
                    message.sellEndTime = NullableString.internalBinaryRead(reader, reader.uint32(), options, message.sellEndTime);
                    break;
                case /* string currency */ 6:
                    message.currency = reader.string();
                    break;
                case /* auth.NullableString actionId */ 7:
                    message.actionId = NullableString.internalBinaryRead(reader, reader.uint32(), options, message.actionId);
                    break;
                case /* string actionName */ 8:
                    message.actionName = reader.string();
                    break;
                case /* auth.NullableString venueId */ 9:
                    message.venueId = NullableString.internalBinaryRead(reader, reader.uint32(), options, message.venueId);
                    break;
                case /* string venueName */ 10:
                    message.venueName = reader.string();
                    break;
                case /* auth.NullableString planId */ 11:
                    message.planId = NullableString.internalBinaryRead(reader, reader.uint32(), options, message.planId);
                    break;
                case /* auth.NullableString planName */ 12:
                    message.planName = NullableString.internalBinaryRead(reader, reader.uint32(), options, message.planName);
                    break;
                case /* repeated string data */ 13:
                    message.data.push(reader.string());
                    break;
                case /* auth.NullableString incompatibilityReason */ 14:
                    message.incompatibilityReason = NullableString.internalBinaryRead(reader, reader.uint32(), options, message.incompatibilityReason);
                    break;
                case /* auth.NullableBool fullNameRequired */ 15:
                    message.fullNameRequired = NullableBool.internalBinaryRead(reader, reader.uint32(), options, message.fullNameRequired);
                    break;
                case /* auth.NullableBool phoneRequired */ 16:
                    message.phoneRequired = NullableBool.internalBinaryRead(reader, reader.uint32(), options, message.phoneRequired);
                    break;
                case /* auth.NullableBool fanIdRequired */ 17:
                    message.fanIdRequired = NullableBool.internalBinaryRead(reader, reader.uint32(), options, message.fanIdRequired);
                    break;
                case /* auth.NullableBool ticketRefundAllowed */ 18:
                    message.ticketRefundAllowed = NullableBool.internalBinaryRead(reader, reader.uint32(), options, message.ticketRefundAllowed);
                    break;
                case /* auth.NullableBool ticketReissueAllowed */ 19:
                    message.ticketReissueAllowed = NullableBool.internalBinaryRead(reader, reader.uint32(), options, message.ticketReissueAllowed);
                    break;
                case /* auth.NullableUInt64 maxTickets */ 20:
                    message.maxTickets = NullableUInt64.internalBinaryRead(reader, reader.uint32(), options, message.maxTickets);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GatewayEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* auth.Gateway gateway = 1; */
        if (message.gateway)
            Gateway.internalBinaryWrite(message.gateway, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string eventId = 2; */
        if (message.eventId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.eventId);
        /* string eventUid = 3; */
        if (message.eventUid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.eventUid);
        /* string showTime = 4; */
        if (message.showTime !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.showTime);
        /* auth.NullableString sellEndTime = 5; */
        if (message.sellEndTime)
            NullableString.internalBinaryWrite(message.sellEndTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string currency = 6; */
        if (message.currency !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.currency);
        /* auth.NullableString actionId = 7; */
        if (message.actionId)
            NullableString.internalBinaryWrite(message.actionId, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string actionName = 8; */
        if (message.actionName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.actionName);
        /* auth.NullableString venueId = 9; */
        if (message.venueId)
            NullableString.internalBinaryWrite(message.venueId, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* string venueName = 10; */
        if (message.venueName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.venueName);
        /* auth.NullableString planId = 11; */
        if (message.planId)
            NullableString.internalBinaryWrite(message.planId, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableString planName = 12; */
        if (message.planName)
            NullableString.internalBinaryWrite(message.planName, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated string data = 13; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(13, WireType.LengthDelimited).string(message.data[i]);
        /* auth.NullableString incompatibilityReason = 14; */
        if (message.incompatibilityReason)
            NullableString.internalBinaryWrite(message.incompatibilityReason, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableBool fullNameRequired = 15; */
        if (message.fullNameRequired)
            NullableBool.internalBinaryWrite(message.fullNameRequired, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableBool phoneRequired = 16; */
        if (message.phoneRequired)
            NullableBool.internalBinaryWrite(message.phoneRequired, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableBool fanIdRequired = 17; */
        if (message.fanIdRequired)
            NullableBool.internalBinaryWrite(message.fanIdRequired, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableBool ticketRefundAllowed = 18; */
        if (message.ticketRefundAllowed)
            NullableBool.internalBinaryWrite(message.ticketRefundAllowed, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableBool ticketReissueAllowed = 19; */
        if (message.ticketReissueAllowed)
            NullableBool.internalBinaryWrite(message.ticketReissueAllowed, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* auth.NullableUInt64 maxTickets = 20; */
        if (message.maxTickets)
            NullableUInt64.internalBinaryWrite(message.maxTickets, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message auth.GatewayEvent
 */
export const GatewayEvent = new GatewayEvent$Type();
